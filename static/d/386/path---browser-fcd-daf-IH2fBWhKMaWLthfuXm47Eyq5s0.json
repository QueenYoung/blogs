{"data":{"site":{"siteMetadata":{"title":"😏","author":"Yang Kui"}},"markdownRemark":{"id":"bec1ca1a-6041-5ce2-9c29-d56adb52d701","html":"<p>原文系列: <a href=\"https://developers.google.cn/web/updates/2018/09/inside-browser-part1\">https://developers.google.cn/web/updates/2018/09/inside-browser-part1</a></p>\n<p>之前，我们提到了 Chrome 的多进程构架和 URL 导航的实现。在这片文章中，我们要一起去看看渲染进程到底做了什么</p>\n<p>渲染过程（Render Progress）和 Web 的性能息息相关。也因为在渲染过程中会发生很多事情，本文仅仅介绍它的冰山一角。如果你想深入的了解，<a href=\"https://developers.google.cn/web/fundamentals/performance/why-performance-matters/\">Why Performance Matters</a> 有更多的资源。</p>\n<h2>渲染过程处理 Web 内容</h2>\n<p>渲染过程负责在 Tab 中发生的一切事情。在一次渲染过程中，主线程会处理绝大部分你为用户准备的代码。如果还包含了 Web Worker 或者 Service Worker（PWA） 的代码，这部分会由 Worker 线程来处理。<strong>Compositor（合成）</strong> 和 <strong>Raster（栅格）</strong>也属于渲染进程的一部分，使页面渲染的更为高效和平滑。</p>\n<p>渲染进程的核心任务是将 HTML，CSS，JavaScript 转化成用户可以与之交互的 Web 网页。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/bdfa66a4ef1fbd2805797bc4cd90f8d8/3c337/renderer.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 52.601156069364166%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABbklEQVQoz2WRyXLCQAxE/f9/w5EqDgQ4kIrBG3ghBuxiD2CzQ9jMY0QoV6UPY02P1GrJWpZlcRx/fum22+l0gjAMPc/zfZ9LW4Gr67q2bf8oWJY1m82out/vGp/RaOT5gem0PxTK5bJhGCTput5sNk3T5Fqr1RBCtNvtIvEqHgwGnoLjOJZtkxEEwfcfQgWCXq+HFyFxOp1O9/u9BoUl0qIoJu73+1kOyN9uNwnkvF6vBGmaJkminc9nqNPp9C7YbreHw0EmvFwuML8KURSt12vJ2e121GubzWaxWGCjUChUKhWEYJkNezwhj/p8Pl+tVsVi8e2LBs9iZk4U6vV6tVoliTe06LNcLo/HI1fIVqvF8MPhkO1OJhOqcKFhjIdSqcQPECHxiXPkxSdXfLIa1i5yr87sAyX08uuRJVMvWoA9NRoN/gWOSB6Px8/OqGb/QCqjYkqWLIz0FOa1MJbBh/HSHBgSYc48CfMOMMvrA+t4W7C5eyUwAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"renderer\"\n        title=\"\"\n        src=\"/blogs/static/bdfa66a4ef1fbd2805797bc4cd90f8d8/42603/renderer.png\"\n        srcset=\"/blogs/static/bdfa66a4ef1fbd2805797bc4cd90f8d8/f931c/renderer.png 200w,\n/blogs/static/bdfa66a4ef1fbd2805797bc4cd90f8d8/e8031/renderer.png 400w,\n/blogs/static/bdfa66a4ef1fbd2805797bc4cd90f8d8/42603/renderer.png 800w,\n/blogs/static/bdfa66a4ef1fbd2805797bc4cd90f8d8/3c337/renderer.png 865w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n  </span>\n  </a>\nFigure 1: 渲染进程包括了一个主线程，Worker 线程，一个 Compositor 线程 和一个 Raster 线程。</p>\n<h2>Parsing</h2>\n<h3>DOM 的创建过程</h3>\n<p>当渲染进程接收到来自 Navigation（详情看 Part2）的提交信息并开始接受 HTML 数据的时候，主线程开始将 HTML 中的字符串转化成 <strong>D</strong>ocument <strong>O</strong>bject <strong>M</strong>odel（<strong>DOM</strong>）</p>\n<p>DOM 即是浏览器内部呈现网页的方式，同时也是一种开发者可以通过 JavaScript 与之交互的数据结构和 API。\n<a href=\"https://html.spec.whatwg.org/\">HTML Standard</a> 定义了将 HTML 转化成 DOM 的过程。你应该注意到过，浏览器从来不会在解析 HTML 的时候抛出一个错误。比如，少了 <code class=\"language-text\">&lt;/p&gt;</code> 的标签是一个合法的 HTML。像 <code class=\"language-text\">Hi! &lt;b&gt;I&#39;m &lt;i&gt;Chrome&lt;/b&gt;!&lt;/i&gt;</code> （b 标签在 i 之前就闭合了）这种错误的标记，会被浏览器看成 <code class=\"language-text\">Hi!&lt;b&gt;I&#39;m &lt;i&gt;Chrome&lt;/i&gt;&lt;/b&gt;&lt;i&gt;!&lt;/i&gt;</code> 来理解。这是因为 HTML 的标准就是特意设计成能够将错误优雅的处理掉。如果你好奇这内部的细节，可以阅读 HTML 标准中的 <a href=\"https://html.spec.whatwg.org/multipage/parsing.html#an-introduction-to-error-handling-and-strange-cases-in-the-parser\">An introduction to error handling and strange cases in the parser</a> 这一节。</p>\n<h3>子资源加载</h3>\n<p>一个网页通常还会有图片，CSS 和 JS 等这些外部资源。这些文件需要从网络或者缓存中被加载。主线会在解析 HTML 文件并构建 DOM 的过程中，一个一个的处理它们。但是为了提速，“（预加载扫描器）preload scanner” 会并行运行。如果存在 <code class=\"language-text\">&lt;img&gt; 和 &lt;link&gt;</code> 在 HTML 中，预加载扫描器会默默地查看这些标记，并在浏览进程中向 network 线程发送请求。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/fa689d6a31b8687522c58774c8d9d064/3c337/dom.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 52.601156069364166%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABc0lEQVQoz22S2XKCUAyGef+namecYZi2FJFNAXfZioqK4lKgH8Txqrk45OTkXxJV2rZdLBbax6fp+YHvh2Hoed54PA6CwHEc13V936cyGo1++hgOh2magmqaRuGzXq8dzzNM6/3tGbqu0/TVx3cfg8HAsixY4Mqy7AkGic5kMrFtG3rU0ERfzldMp1OpzGazzWaTJMn5fFaAGYZhmiasqAG+XC5VVUFc1zUdXG+32+PxIN9ut5qmIV6W5W63U6je73fwsM7n8zzP6cAOxgDDSB2fIPf7fRzHqqoyFMpcFaqn0wllzPz2AUZWQoVZcAv4er1SZwXgj8fjcrnslOFASjYEGcqHw0EUQHKFl1l4avtgHE5sd8oQ8GEN0ENJN0OS88xEsideV6sV4qyWnB8Msx2YqcDThFUskAPGDvSciAPgjyAnQQNtyHRgPiyTVYFHFjWuAkYh74NuvJD8Y5sqxPIHIMQbb0VRyCkJuxBZ8iiKKP4Bs75RmkY8U9EAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"dom\"\n        title=\"\"\n        src=\"/blogs/static/fa689d6a31b8687522c58774c8d9d064/42603/dom.png\"\n        srcset=\"/blogs/static/fa689d6a31b8687522c58774c8d9d064/f931c/dom.png 200w,\n/blogs/static/fa689d6a31b8687522c58774c8d9d064/e8031/dom.png 400w,\n/blogs/static/fa689d6a31b8687522c58774c8d9d064/42603/dom.png 800w,\n/blogs/static/fa689d6a31b8687522c58774c8d9d064/3c337/dom.png 865w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n  </span>\n  </a>\nFigure 2: 主线程解析 HTML 文档并构建 DOM 树</p>\n<h3>JavaScript 会堵塞解析</h3>\n<p>当 HTML 解析器找到一个 <code class=\"language-text\">script</code> 标签的时候，它会暂停解析 HTML 文档，并开始下载，解析并执行 JS 代码。为什么？因为 JS 可以使用像 <code class=\"language-text\">document.write()</code> 这种改变了整个 DOM 结构的方法来改变文档的形状（shape of the document)。这就是为什么 HTML 解析器在它可以继续解析 HTML 文档之前，必须等待 Javascript 运行结束。如果你对 JS 的执行细节好奇的话，<a href=\"https://mathiasbynens.be/notes/shapes-ics\">V8 团队有一篇关于它的博客介绍</a></p>\n<h2>暗示浏览器哪些资源是可以加载的</h2>\n<p>Web 开发者有很多种方式可以按时浏览器如何恰当地加载资源。如果你的 JS 不使用 <code class=\"language-text\">document.write()</code>，你可以给 <code class=\"language-text\">script</code> 标签添加 <code class=\"language-text\">async</code> 或者 <code class=\"language-text\">defer</code> attribute。这样浏览器就异步的加载和运行 JS 代码，而不会堵塞解析过程。你同时也可以在恰当的时候使用 <a href=\"https://developers.google.cn/web/fundamentals/primers/modules\">JavaScript module</a>。<code class=\"language-text\">&lt;link ref=&quot;preload&quot;&gt;</code> 也是一种通知浏览器，当前资源可以尽快下载的方式。可以通过阅读 <a href=\"https://developers.google.cn/web/fundamentals/performance/resource-prioritization\">Resource Prioritization – Getting the Browser to Help You</a> 了解更多。</p>\n<h2>Style calculation</h2>\n<p>因为 CSS 的存在，仅仅有一个 DOM 是不足以让浏览器了解整个网页会是怎么样的。主线程会解析 CS，并为每一个 DOM 节点计算出最终样式。这些信息会基于 CSS 选择器来呈现每一个元素被应用了哪些样式。你可以在通过开发者工具的 <code class=\"language-text\">computed</code> 来看到这些信息。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/fb7d195814a04c6ed98eab8dbda477c6/3c337/computedstyle.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 52.601156069364166%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABiklEQVQoz1WRWY+CQBCE+f//xsRolBfXI2YDKiKKgujiiYrifUVlP2YS3e2Hoafpqq7qUeI49v2fb003bcd1HM/zuiIcx7Esq91uk3c6HdM0l8vlarVqNpuLxQLU6/VS+EwmE7vbM1rWF1EsFgqFRqNBk67r9XrdMAzOcrksiVzX/YDH47Ft21RbpgmAabKD6Pf78kTOcDj0RJBMp9P5fH46nRTkwQ3a931yTsn6EPF8Pu/3+/V6vd1u+/1+vV5Xq1UYj8cjuULHZrPhLi1FURSG4WAwqNVq6NQ0DTqK9MxmMwYCxlQQBBQVOEDSB5IcMefzmUo2m8VnJpMBjE7+giyVSsxAwmg0SsDw8ZsLK5V4KjjP5/OVSiWXy7EexCMQDKJiEbQlYMwcDoeeCFjkZFaYSqVUVU2n0/Bib7vd4vwNBpKAL5cLqnhGHgzxu92OCawUPLtll+QMD0Sg+R8YVgbih5N/PAwVdNKBVE6kyW0zRtY/soFhErfvrbDYUARXzuhPwEuRBpox8gsmH01pB0VyDQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"computedstyle\"\n        title=\"\"\n        src=\"/blogs/static/fb7d195814a04c6ed98eab8dbda477c6/42603/computedstyle.png\"\n        srcset=\"/blogs/static/fb7d195814a04c6ed98eab8dbda477c6/f931c/computedstyle.png 200w,\n/blogs/static/fb7d195814a04c6ed98eab8dbda477c6/e8031/computedstyle.png 400w,\n/blogs/static/fb7d195814a04c6ed98eab8dbda477c6/42603/computedstyle.png 800w,\n/blogs/static/fb7d195814a04c6ed98eab8dbda477c6/3c337/computedstyle.png 865w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n  </span>\n  </a>\nFigure 3: 主线程解析 CSS 得到计算过的样式</p>\n<p>即使你不提供任何 CSS，每一个 DOM 节点还是会有一个被计算过的样式。<code class=\"language-text\">&lt;h1&gt;</code> 标签看上去会比 <code class=\"language-text\">&lt;h2&gt;</code> 更大，并且每一个元素的 margin 也是不一样的。这是因为浏览器维护了一个默认样式表。如果你想了解 Chrome 的默认样式，可以阅读<a href=\"https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/css/html.css\">源码</a></p>\n<h2>Layout</h2>\n<p>现在渲染进程知道了 DOM 的结构和每一个节点的样式，但是这些信息还不足以去渲染一个页面。相信你在电话的另一头努力地给你的朋友描述一幅画。“有一个巨大的红色的圆和一个小一点的蓝色的正方形”是不足以让你的朋友想象出这幅画的样子的。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/0658494542e14f7db66b913c02c03202/3c337/tellgame.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 53.294797687861276%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB10lEQVQoz21Su47TQBQdim0QEgUUQLESP7D8AtI2iHYrOkRBS02zH4D4AUo6N2ELQrTtJqFIsnlY5GEltmfs8dqOTZLNy3b8iPfEXu1D2iv7auy555x7zwzhnHuel6ZpkiRBECyXy/V6PZ/PF4vFarXCZxiG2+0WBXEcp/eDMMYkSQIFkGCJwjD2/RTlqI2iTRjmFFEUVatVy7LGWWAfYsQwDNM0S6XSdDrFAizm5fxCY1TnoiTZlmXbNtgLhUKr1apUKr1er1gslstldERAAwxowM0oRX/ezx+ztwfu0WH7z+8w69b3fVEUkQeDAbpDFgSh0WgQWZYnk0maDc3ssf+v7e4//v9qjz4h/Q/vd7+zgTEdZJrNJpSHwyEgAJLRaASHcgPEkSwXhPPnjzqvn7Zf7n38/P3NSSAoO59klf7NQlGUWq2We0y63W6+gkkYGHnx5ZP7jKwPXrw7PiVf6bezMTb5hQmNTqeDNbLrujvwXeupqkZJEm8CX2xGmvJL2x63kto4TuMN1TQUoGHHcaBPKb0F5ycJZY0xzg1jOjMcZ2bqnsNdkzOm2baVgyGrqup12+mDsePK3uy5CUwLw/r9/vUluQ95OHCQ2IVavV7XdR2e57ftCp5ZSInelRfHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"tellgame\"\n        title=\"\"\n        src=\"/blogs/static/0658494542e14f7db66b913c02c03202/42603/tellgame.png\"\n        srcset=\"/blogs/static/0658494542e14f7db66b913c02c03202/f931c/tellgame.png 200w,\n/blogs/static/0658494542e14f7db66b913c02c03202/e8031/tellgame.png 400w,\n/blogs/static/0658494542e14f7db66b913c02c03202/42603/tellgame.png 800w,\n/blogs/static/0658494542e14f7db66b913c02c03202/3c337/tellgame.png 865w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n  </span>\n  </a>\nFigure 4: A person standing in front of a painting, phone line connected to the other person</p>\n<p>Layout 是一个找到元素的几何信息的过程。主线程通过遍历 DOM，计算样式，并创建一个包换了 x y 坐标信息和边框大小的 layout 树。Layout 树可能和 DOM 树很相似，但是它仅仅包含了在能在页面中被看到的信息。比如 <code class=\"language-text\">display: none</code> 一旦被应用到每个元素上，这个元素就不是 layout 树的一部分。相似的，如果一个伪元素 <code class=\"language-text\">p::before { content: &quot;Hi!&quot; }</code>被应用饿了，它虽然不会出现在 DOM 树上，但是属于 layout 树。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/0c1de85206f0d177f93a70931a0f8272/3c337/layout.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 52.601156069364166%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABjElEQVQoz1WS6Y6CQBCEef/30QR/aUTiZlmN3AoeCCqCovG+Vvyc2d1kO2bohqqumm6Vsiwnk8nHp2H5QRgGw+HQ9/1+vx+Goeu65EEQeJ5nWVae56vVqtfrLZdLWM/nU+GRxLHr+V3TbjQa9Tq/eqfTAfQloitC0zTbtulC0yzLfshJkvAKKduyTNN0HGcwGIQicPGXjEYjmYzH49lslqbp8XhUoNEYe3ygNwjZ9X6/Xy6XbxGPx4MT9Hq9brfbYA6HA1dQAPGgRh+3zWaTEv58PkftdrvJXpwwF4uFruuIoVwUhbLf7xkJN+SqrVarUqlAA3o+n7FDI/hgOJGhOzTKKIre5EQEfMhYUlWVz4ZhIIIyfJLNZkOvUoR0Af9N5mK73Y5N1Go1mNVqFTQ60+mUFaJAiWGgwKBxeU7yN/l0OsVxzDWYliGCwTAhSjlSZkEXJoQau2D52MTUdrtVWBrTZ+8gQJNLV2her1dyPDMFANL5P9upCAaDPf5DcoyyJIFJd16iU/wGOe04XwjcTY6e4hgvAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"layout\"\n        title=\"\"\n        src=\"/blogs/static/0c1de85206f0d177f93a70931a0f8272/42603/layout.png\"\n        srcset=\"/blogs/static/0c1de85206f0d177f93a70931a0f8272/f931c/layout.png 200w,\n/blogs/static/0c1de85206f0d177f93a70931a0f8272/e8031/layout.png 400w,\n/blogs/static/0c1de85206f0d177f93a70931a0f8272/42603/layout.png 800w,\n/blogs/static/0c1de85206f0d177f93a70931a0f8272/3c337/layout.png 865w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n  </span>\n  </a>\nFigure 5: 主线程遍历 DOM 树，通过已经计算的样式，得到 layout 树</p>\n<p>确定页面的布局是一项由挑战性的任务。即使是最简单的页面布局，如从上到下的 block flow，也必须考虑字体的大小以及在哪里划分它们，因为它们会影响段落的大小和形状，还会影响下一段所需的位置。</p>\n<p><a href='/blogs/layout-d79962918f183bf37afdfbbec0b45780.mp4'>layout.mp4</a></p>\n<p>Figure 6: 因为一个断行的改变，layout 也跟着改变</p>\n<p>CSS 还能让元素浮动到一边，隐藏超出边界的部分，并修改写入方向。你可以想象到，layout 阶段其实是非常复杂的任务。在 Chrome 中，有专门一个团队的工程师致力于 layout 的工作。如果你想了解更多有关他们的工作细节，<a href=\"https://www.youtube.com/watch?v=Y5Xa4H2wtVA\">few talks form BlinkOn Conference</a> 记录了大量的有趣的内容。</p>\n<h2>Paint</h2>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/d8fe81b968531c8b3d4767006ea9725d/3c337/drawgame.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 37.45664739884393%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAABL0lEQVQY05VPPU+DUBR9iZOrcTBODk6auDv4M5z7cxydjXFxMsbJ0YnNpBKIaYSQgnyWPngUXvkoUAh4oEtXz3bPveeec4jrOCzLqaFT16HrbLmkjEWmabquG8dxtAfHcZqm8X3/Z0RZliRIs1744Fen2c1Fr8pdP2A+n6dpWlXVZkSe513XQb8YgZUgCLIsk4Cvs8ktOyL05ODl7uk9GsS6YeAiSRJKqWVZQRBAzxhTFEXTNFVVPc8Lw5CwvGhen9dnh4vry+P74PxtEBvGL67rurZtG3d4AZJzruu6KIowRzQwBE3qvs++PpPZ94O6fZwV7baGA9wQGOa7CKiAL3iHRxglSUJ/slqtkjjGkm/KLo/bAisOEg35HsCCadsWaafTKboMzv1/ADdtxK7IHzccdTm16O1FAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"drawgame\"\n        title=\"\"\n        src=\"/blogs/static/d8fe81b968531c8b3d4767006ea9725d/42603/drawgame.png\"\n        srcset=\"/blogs/static/d8fe81b968531c8b3d4767006ea9725d/f931c/drawgame.png 200w,\n/blogs/static/d8fe81b968531c8b3d4767006ea9725d/e8031/drawgame.png 400w,\n/blogs/static/d8fe81b968531c8b3d4767006ea9725d/42603/drawgame.png 800w,\n/blogs/static/d8fe81b968531c8b3d4767006ea9725d/3c337/drawgame.png 865w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n  </span>\n  </a>\nFigure 7: 一个人拿着画笔站在画布前，想着应该先画圆还是先画正方形</p>\n<p>有了 DOM，style，layout 还不足于渲染一个页面。假设你正在努力画一幅画，你知道画的大小，形状，每一个元素所在的位置，但是你还是需要判断绘制它们的顺序。\n比如，<code class=\"language-text\">z-index</code> 可能会被设置到当前元素上，在这种情况下，如果按 HTML 定义的顺序来绘制就会得到错误的结果。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/785924a8744dfda1428cc692e2c3f411/73363/zindex.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 53.44062153163153%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABa0lEQVQoz32S/W6CQBDE7/2fo3/1KUxM1JgQg5CqIKJyIigfIgpYRforV02bmG7iZW93bmdmUfR6vclkYhjGbDYzTdP3/SiK9vv9brcLw9BxHNd1pZQkm81msVhYlrVer5fLZZqmQtf14XA4GAw0Tev3+5wfbVAHCojT8zwIbNtmChwkx+Pxer2Ky+UCCYNpMBvcdDo1DQNCT0pegp7P50gbjUbookJ+u92aphHc6fEGPbCNx2NUUKSXhKGaKB9TsMMV/M9jqnir61r5oVQU5yiOA9+X729VnpPTbV6FiONYZeiHAZPb7ZbxnI5tIwGHcK5WK5D3+/3PYwwHQcAJDjNssiiKJEnYfHo4gEZOt9vtdDrsBdvUWYrSIvjVbZAwBf7PNsj5ZmVZslhaVMCUbTBdSfjeNhdKVVWBhhnx7A/ZyKHLerIse+05+xV5np8foXIY8Mz3xxFD1YKezkXzbyDqdDqR8Jd4unvGF3HhXceMYMsUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"zindex\"\n        title=\"\"\n        src=\"/blogs/static/785924a8744dfda1428cc692e2c3f411/42603/zindex.png\"\n        srcset=\"/blogs/static/785924a8744dfda1428cc692e2c3f411/f931c/zindex.png 200w,\n/blogs/static/785924a8744dfda1428cc692e2c3f411/e8031/zindex.png 400w,\n/blogs/static/785924a8744dfda1428cc692e2c3f411/42603/zindex.png 800w,\n/blogs/static/785924a8744dfda1428cc692e2c3f411/5b8b9/zindex.png 1200w,\n/blogs/static/785924a8744dfda1428cc692e2c3f411/c7ea5/zindex.png 1600w,\n/blogs/static/785924a8744dfda1428cc692e2c3f411/73363/zindex.png 1802w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n  </span>\n  </a>\nFigure 8: 页面的元素按 HTML 元素中定义的元素，导致了错误的结果。因为 z-index 没有被考虑在内</p>\n<p>在绘制（Paint）阶段，主线程遍历 layout 树来创建绘制记录（Paint record)。绘制记录是一个绘画过程的注解，如“先背景，接着文本，然后矩形”。如果你使用过 <code class=\"language-text\">canvas</code>，那么这个过程对你来说应该很熟悉。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/a68fd128fc59b9b2bed3511fcf223c94/3c337/paint.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 52.601156069364166%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABeklEQVQoz22R23KCQBBE+f+v0iq1jFFQQECBCOJdQfGKaCQHpqzkIfOwO9U7090zqxRFEYbBx2fXsF3PdX3fdxxnPB57nmdZFrnrurZtG4ax3W53u12/31+v13S9Xi+FazabWbaj6Wa9VqvXOWqqqg4Gg24V5JqmNRoN0zRhgeu3mU6RMg1D1/XhcCiyxGQy+foTIPgCnM/nq9XqcrkolCICaxAE5JywfleBwnK5XCwWaZoCns/nOI7b7TbikivP55MLvizLxExRRZ7nEKEWhiE6IJTB1Wq1GARkv98rFN3v99FoxD6ogAtNSTDJzKxqs9kIXa/Xw8jxeJxOp2WzCALhGZ9Qgsh6yUnAhVdMyYntsvnxeHDJGnGYVsGXnE4n7DSbzU6nA7UMT0EURXSyrSRJlOv1KrMB8bG80ckbpHgD4QllSjGPF1Z9u90oKJUpZVuMgRmK4MY8RExOG+bRl4X9Y1v+g03CTTPekipAoirQFzB+B20gh8PhB0XOU3hbyxq5AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"paint\"\n        title=\"\"\n        src=\"/blogs/static/a68fd128fc59b9b2bed3511fcf223c94/42603/paint.png\"\n        srcset=\"/blogs/static/a68fd128fc59b9b2bed3511fcf223c94/f931c/paint.png 200w,\n/blogs/static/a68fd128fc59b9b2bed3511fcf223c94/e8031/paint.png 400w,\n/blogs/static/a68fd128fc59b9b2bed3511fcf223c94/42603/paint.png 800w,\n/blogs/static/a68fd128fc59b9b2bed3511fcf223c94/3c337/paint.png 865w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n  </span>\n  </a>\nFigure 9: 主线程遍历 layout 树并生成绘制记录</p>\n<h3>Updating rendering pipeline is costly</h3>\n<p><a href='/blogs/trees-4fb0aeab900ba7deeab02d06057f464e.mp4'>trees.mp4</a></p>\n<p>Figure 10: 有序的生成 DOM ，Style，Layout，Paint Trees</p>\n<p>想要理解渲染一条龙，最重要的一点是<strong>每一步中，都会使用上一个操作的结果作为新的数据。</strong> 比如修改了 layout 树，那么 paint 树也需要重新生成。\n如果你打算为某些元素加动画，浏览器必须在每一帧都重复这些过程。大多数显示器 1 秒刷新 60 次屏幕（60 fps）。当物体在屏幕中移动的时候，出现在每一帧中，人眼就会认为这段动画十分平滑。然后，如果动画在某段时间内丢帧了，页面就会看上去“卡顿”</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/fbcb48cd931be64c96ac87a3fa1ee177/6fdd2/pagejank1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 23.1%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/ElEQVQY02WN3U+CUADF+f/f3HrpoVecFNK81crNrbx0uwgCgYEwMK5XqN3SIR9SLinsKdd5ONvZOTs/7vuf6l8nhGia5vu+5/mGYWRZtq/q+u+SK4t8W5V5nldl8Vltsmz9tf1YLZdhOEvTdE7IevXexN2hmpfGuVbnBpj05GJ4DO6BHrXal6doCn22KfKyLI86V7zsuWzTcHaH2D35enDXhwovdLFu9fq3gniOjae22FMUjBDihTOoWYMh6oqi604lSZJlWVVVAADGmJtY1ktMtdGIRM8LOscP6I29TqxH0zQppfp4HM3CJF5ACJMkcRzHtu04joMgYIz9ACMYBWmHluTAAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"pagejank1\"\n        title=\"\"\n        src=\"/blogs/static/fbcb48cd931be64c96ac87a3fa1ee177/42603/pagejank1.png\"\n        srcset=\"/blogs/static/fbcb48cd931be64c96ac87a3fa1ee177/f931c/pagejank1.png 200w,\n/blogs/static/fbcb48cd931be64c96ac87a3fa1ee177/e8031/pagejank1.png 400w,\n/blogs/static/fbcb48cd931be64c96ac87a3fa1ee177/42603/pagejank1.png 800w,\n/blogs/static/fbcb48cd931be64c96ac87a3fa1ee177/6fdd2/pagejank1.png 1000w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n  </span>\n  </a>\nFigure 11：Animation frames on a timeline</p>\n<p>即使你的渲染操作能跟上屏幕的刷新，但是因为这些计算是发生在主线程上，这意味着当有其他的 JS 代码运行的时候，动画就会“掉帧”</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/6e35a283b1b93f266a18f739475db1ea/6fdd2/pagejank2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 23.1%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDElEQVQY02WOXU+CUACG+UOurZV/N7swi1auRutjkWVAxAkhDoi4QEAkOBZ1IfLlOeTW7KZn78V78bzbS9UbyKaUZTU0x+BFnbj+QNF0Y/Tf+YUqs7QsCkJwvkyrMq9xYo+VBL1FU/177nwhe5G4JI9JjnCVFdmyqiqMMVkPMKbanBkuVq7vHw2iNPVrdfeTbWTcVnjTtLrb6xB5Bz83aqU50i+PlXlarv4uUMwdz4vgoNPhVPOWZc+7bcuQTujWQ++qf39NH+5DVej3Lk7plqIqe/QZxwsASAzDiKJIGfB1FgQAAN91PM97EqX3+EPThxrUp0Eoy6oz8WZh/MgJURRZpgEhDILAtm2E0A9U1ABD8UOCoQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"pagejank2\"\n        title=\"\"\n        src=\"/blogs/static/6e35a283b1b93f266a18f739475db1ea/42603/pagejank2.png\"\n        srcset=\"/blogs/static/6e35a283b1b93f266a18f739475db1ea/f931c/pagejank2.png 200w,\n/blogs/static/6e35a283b1b93f266a18f739475db1ea/e8031/pagejank2.png 400w,\n/blogs/static/6e35a283b1b93f266a18f739475db1ea/42603/pagejank2.png 800w,\n/blogs/static/6e35a283b1b93f266a18f739475db1ea/6fdd2/pagejank2.png 1000w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n  </span>\n  </a>\nFigure 12: 在动画帧的时间线上，有一帧被 JS 堵塞了</p>\n<p>你可以使用 <code class=\"language-text\">requestAnimationFrame</code> 将 JS 操作拆分成一小片，它们会分散在每一帧中运行。关于这个话题更深入的部分，请看 <a href=\"https://developers.google.cn/web/fundamentals/performance/rendering/optimize-javascript-execution\">Optimize JavaScript Execution</a></p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/7b1959d9953869798ba89282c6533bd2/6fdd2/raf.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 23.1%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsTAAALEwEAmpwYAAABD0lEQVQY01WPW0+DQBSE+f//wAejjZoWrLG6mGpUwFAot7JA1VibugWMraG7UOUi6oKo8cHvYWYyDydnGNHxo/n+Y2ALzpQ+s7doAa+vPpbHordaoB5+0qRxkIe7Uz8cumZNQN1Q0foHBjhLNOGFy544S3y4CRTX9e89eQO4ZHLXV0ROekjnbgtImoHCmbW1fsljQhBCGGPm7ORIUUftDjfSlXNB5dp7N964e9i/OAWDgdFhD2xDVYZwp7XtQch2eZ4HsiwDAFRVZT5pRWkVBEGa5eVbkSTr1zSNm+NxkucZIXiFcVFkGJOyfK//w/xa80MYhhBCTdN0XW/Utm3LskzTbELTG4YRRdH33j8opV87Zv9mDQAZNwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"raf\"\n        title=\"\"\n        src=\"/blogs/static/7b1959d9953869798ba89282c6533bd2/42603/raf.png\"\n        srcset=\"/blogs/static/7b1959d9953869798ba89282c6533bd2/f931c/raf.png 200w,\n/blogs/static/7b1959d9953869798ba89282c6533bd2/e8031/raf.png 400w,\n/blogs/static/7b1959d9953869798ba89282c6533bd2/42603/raf.png 800w,\n/blogs/static/7b1959d9953869798ba89282c6533bd2/6fdd2/raf.png 1000w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n  </span>\n  </a>\nFigure 13：在动画帧的时间线上，更小的 JS 块</p>\n<h2>Compositing</h2>\n<h3>你怎样 draw 一个页面</h3>\n<p><a href='/blogs/naive_rastering-a0634ba076324953ca7af0a80e55eb81.mp4'>naive_rastering.mp4</a></p>\n<p>Figure 14: naive 的栅格化过程</p>\n<p>现在浏览器知道了文档结构，每一个元素的样式，页面的几何信息，和绘制顺序，接下来怎样 draw 出这个页面呢？将这些信息转化为像素并呈现在屏幕上的过程被称为<strong>栅格化</strong>。\n可能一个比较 naive 的处理这个方式是：仅仅栅格化视口的部分。如果用户滚动着页面，那么在移动帧的过程中，通过继续栅格化来填充缺失的部分。这也是 Chrome 刚发布的时候，采用的策略。然后现代浏览器会使用一种被称为合成（compositing）的更为牛逼（sophisticated）的方式。</p>\n<h3>什么是合成</h3>\n<p><a href='/blogs/composit-42e8d29f2a2648a18da3571f345453e0.mp4'>composit.mp4</a>\nFigure 15: 合成过程</p>\n<p>合成是一种用来将一个界面分为多个层，分别将它们栅格化，并在一个叫做合成器的线程中将它们重新合并成一个界面的技术。如果滚动发生了，因为每一个图层（Layer）都早已栅格化，现在说需要做的事情仅仅是合成一个新的帧。而动画也可以通过移动层并将它们组合成一个新的帧的方式来实现。\n你可以使用开发者工具中的 Layers 面板来查看你的网页是被分成了哪些层。</p>\n<h3>深入 Layer</h3>\n<p>为了分清楚哪些元素会在哪些图层中出现，主线程需要遍历 layout 树并创建一个 layer 树（在 Performance 面板中，这一部分被称为 Update Layer Tree）。如果界面中那些本该成为单独的层（比如抽屉菜单）却没有成为，你可以使用 CSS 属性 <code class=\"language-text\">will-change</code> 来暗示浏览器，将它提升为一个单独的层。</p>\n<p>你可能会禁不住诱惑让每一个元素都成为一个图层，但是合成大量的层反而会导致这个过程比一帧一帧的栅格化还要慢，关键才是要测量你的渲染性能。关于这个部分的更多细节，请看 <a href=\"https://developers.google.cn/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count\">Stick to Compositor-Only Properties and Manager Layer Count</a></p>\n<h3>Raster and composite off of the main thread</h3>\n<p>一旦 Layer 树已经创建好，并且 Paint 的顺序是确定的，那么主线程就会将这些信息提交到合成器线程中。合成器线程会栅格化每一个 Layer。有些 Layer 可以和整个页面一样大，所以合成器线程会将它们分为多个图块，接着将每一个图块发送给栅格线程。栅格线程栅格化每一个图块，并将它们存在 GPU 的内存中。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/371b5fa654d59f0c8ccb2f4f0658c20a/3c337/raster.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 52.601156069364166%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB0UlEQVQoz01Sy5KbMBDk//8ktxySVPaQKpulYnaNMWCe4ikQIDAE2+W3DU4b55A5iJFQd8/0SHg8HpQmH3PFcIhPSBiG7hiEENM0LctCbtu2YRh1Xa/Xa13Xq6oCahgGAR/GmON62sqcIkRxMpksl0tN0xRFUVUVOVZJkkDkeR7YwfIPnGUZuD3PtVbPsMcbkE3GCIIgiiIA4jj2fR9brJRSzvnhcBBw8+NzDhgQKMkjfj8MIIYOrl4ul7ZtT6fT+Xy+3+99399uN2h2XYdz4U9TRcSxlYltLMLVzNIUmkRFUYAIlUMELNABGBTDyIuA7GazEeqSpZHH3HnoGLvS5ywmrr3f70VRBPdut0OH2+0WOXxqmga/gEQOp4R2XenqfPH+MwmcX9++vH3/Gng2XBCnU5SdpulLHG5jCxcABiPoULlQ8zKLffX9x2oha7/fAsdo67LrNsfjsR/jer3CJLQAFwFAtaAD6RPMC9Y1nDqfEbEiU962vKmKYZzEqz3goYkRQB+asBazlGUZJ0JVZIwGoS75jh7oUp6QqmSP/wImoz3gMXaUjZeD1zCbzZ7goixZXuRZwvI8z2iaMc4r1NaNgQSGvdyG/0jQLVY8Nfz6CxoTRqDyXR/aAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"raster\"\n        title=\"\"\n        src=\"/blogs/static/371b5fa654d59f0c8ccb2f4f0658c20a/42603/raster.png\"\n        srcset=\"/blogs/static/371b5fa654d59f0c8ccb2f4f0658c20a/f931c/raster.png 200w,\n/blogs/static/371b5fa654d59f0c8ccb2f4f0658c20a/e8031/raster.png 400w,\n/blogs/static/371b5fa654d59f0c8ccb2f4f0658c20a/42603/raster.png 800w,\n/blogs/static/371b5fa654d59f0c8ccb2f4f0658c20a/3c337/raster.png 865w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n  </span>\n  </a>\nFigure 17: 栅格线程创建多个位图块，并发送给 GPU</p>\n<p>合成线程还可以根据优先级决定，以便视口（或附近）可以先被栅格化。图层还具有多个 tiliings 用于处理放大操作等。</p>\n<p>一旦图块被栅格化，合成器线程会有一个被称为<strong>draw quads（绘制四边形）</strong>的过程来收集这些图块的信息，以创建一个 <strong>compositor frame（合成帧）</strong>\nCompositor frame 接着会由 IPC 提交到浏览器进程中。此时，可以从 UI 线程中添加其他的合成帧用于浏览器 UI 的改变或者渲染进程。最后这些合成帧会被发送到 GPU 以显示到屏幕上。如果有滚动事件发送，合成器线程会创建新的合成帧发送到 GPU。</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blogs/static/397d4949099dd6d1aaffcb55e8678e37/3c337/composit.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 52.601156069364166%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkElEQVQoz1WS127CQBRE9///hiceQIJgJHABI3fjgg0WHdGCKKHkyBsS5Uos17szc8ezFq/XK88zVTdsP4qjKEmSIAiGw2Ecx57n0UdR5Pu+bdur1Wq9Xg8Gg8ViAevxeAj+isnEC0LTcprN5kdZpmlaltXv92lAs7bbbcdx0EJ0uVzCej6foigK5jDEc13kwzBklFcWA13XZQWQpilrVFaWZVhgvuAMMZ6TNEVov9+DG41GTAZNA4D917twe7/fv8oS1+v1eDzebrfz+cwZPRzpSqJlA/RyuYCB/CskTqfTbrfDsGEYzNxsNmTGfLzM53MIEoeopmm9Xk/uSEUxHo+JoVqtVioVVVUJI02SPM8bjQYhoYtnmTOATqfzj4xJEBwTAN6YQFRIsK/rOvPlEQan0ylxHg6HPzI/nmu1GjcEwdB1pdXikjCp4aTb5YYkn3ep1+ukDYXMfu4ZVUVRmAMIwzTyJmazGdN4c+zgTl4eAHY4JR3BN0BahAQTC9vtlhSQg/D5LnoZJBgaLKAF8hvmbE0ktc1lqQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"composit\"\n        title=\"\"\n        src=\"/blogs/static/397d4949099dd6d1aaffcb55e8678e37/42603/composit.png\"\n        srcset=\"/blogs/static/397d4949099dd6d1aaffcb55e8678e37/f931c/composit.png 200w,\n/blogs/static/397d4949099dd6d1aaffcb55e8678e37/e8031/composit.png 400w,\n/blogs/static/397d4949099dd6d1aaffcb55e8678e37/42603/composit.png 800w,\n/blogs/static/397d4949099dd6d1aaffcb55e8678e37/3c337/composit.png 865w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n  </span>\n  </a>\nFigure 18: 合成器线程创造合成帧的过程。帧先发送到浏览器线程然后发送到 GPU</p>\n<p>合成的优点就是它不依赖主线程。合成线程不需要等待样式的计算或者 JS 的执行。这也是为什么 <a href=\"https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/\">只改变那些会导致合成的属性</a>被认为是创建平滑动画的最佳选择。如果 layout 或者 paint 需要被再次计算，则主线程又会忙碌起来。</p>\n<h2>总结</h2>\n<p>在这篇文章中，我们探索了渲染一条龙：从解析到合成。但愿你现在有能力去越多更多有关网页性能优化的文章。\n在下一篇，也是本系列的最后一篇中，我们将会深入合成线程，一起看看当用户输入事件<code class=\"language-text\">mousemove click</code>的时候会发生什么。</p>","frontmatter":{"title":"Inside look at modern web browser（翻译）","spoiler":null,"date":"2018/10/05"}}},"pageContext":{"slug":"/browser/","previous":{"fields":{"slug":"/git/"},"frontmatter":{"title":"The Junior Git","spoiler":null}},"next":{"fields":{"slug":"/react-lazy/"},"frontmatter":{"title":"React Lazy 的实现原理","spoiler":"简单讨论一下 React.lazy 内部实现"}}}}