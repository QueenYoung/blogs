{"data":{"site":{"siteMetadata":{"title":"😏","author":"Yang Kui"}},"markdownRemark":{"id":"f88bfc8d-dd22-5374-b086-ca0f37647437","html":"<h2>背景</h2>\n<p>从开始接触异步请求，接触 AJAX 和 Promise 后，就会发现这些操作很<strong>「套路化」</strong>。绝大多数的异步操作似乎都可以类似下面 👇 的代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">async</span> <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> rep <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>rep<span class=\"token punctuation\">.</span>data <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n\t  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>生活很美好吧，umh？不过呢，这让整个交互体验变得不那么「人性化」了。因为不论任何时候，网速怎么样，都会先生硬地加载一个 loading，然后在接口返回的时候，<strong>匆匆完事</strong>。如果 loading 的 UI 侵入性比较小的话，可能不是那么让人讨厌，但想象一个全屏幕的 loading：它唰地出现了一下子又消失了。你这个时候就不会觉得这是很好的用户体验了，反而觉得很蠢。</p>\n<p>::NOTE：这里可能应该引用人机交互指南中，不同的响应延迟需要采取的措施::</p>\n<p>所以总结两点，不分青红皂白就 loading，在高速网络下带来的问题</p>\n<ol>\n<li>出现 loading，反而让用户觉得变卡了</li>\n<li>闪烁的体验让人很分裂</li>\n</ol>\n<h2>一个已经存在的解决方案</h2>\n<p>React 用户应该都知道 <code class=\"language-text\">Suspense</code>，可惜的是它目前的用处仅仅是<strong>Code Splitting</strong>。似乎还有稳定问题，React 还没有将它最强大的一面公布出来。当然这是后话，但是如果你看过\n<a href=\"https://www.youtube.com/watch?v=ByBPyMBTzM0&#x26;t=1368s\">Concurrent Rendering in React - Andrew Clark and Brian Vaughn - React Conf 2018</a> 或者这个 <a href=\"https://github.com/facebook/react/tree/master/fixtures/unstable-async/suspense\">Demo</a> ，就知道 <code class=\"language-text\">ConcurrentMode</code> 配合 <code class=\"language-text\">Suspense 的 maxDuration</code> 就能解决上面的问题。比如这样一个场景</p>\n<blockquote>\n<p>懒加载路由 A 的组件，500ms 内没有加载成功则显示 loading</p>\n</blockquote>\n<p>这个通过未来的 React 可以轻松做到</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> LazyHome <span class=\"token operator\">=</span> <span class=\"token function\">lazy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./home'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">App</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ConcurrentMode</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      // 省去一些 Route 相关代码\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Route</span>\n        <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\">render</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>props <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Suspense</span> <span class=\"token attr-name\">maxDuration</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token number\">500</span><span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">fallback</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>BeautifulLoading</span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n            </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>LazyHome</span> <span class=\"token spread\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">...</span><span class=\"token attr-value\">props</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n          </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Suspense</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></span>\n      <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ConcurrentMode</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>可是给我一个现在用不了的解决方案不等于放屁么？根据<a href=\"https://reactjs.org/blog/2018/11/27/react-16-roadmap.html#tldr\">官方的说法</a>，等到 ConcurrentMode 的完成，至少也到 2019 年的 Q2。另外一些强大的库，比如 rxjs，似乎也能轻松做到我们的需求，但是因为门槛高，用户基数不大，不在讨论范围内。\n所以接下来我们才进入本文的正题，<strong>如何用 Promise.race 做到同样的效果</strong></p>\n<p>你可以不用读完，直接看<a href=\"https://codesandbox.io/s/kxzxnnj8vr\">完成代码</a>就行了</p>\n<h2>Promise 的解决方案</h2>\n<p>主要的实现思路就是通过在<strong>请求和超时</strong>中竞争出优先被 settled 的那个 Promise，作出相应的逻辑。\n为了实现的简单，超时的函数应该使用</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">timeout</span> <span class=\"token operator\">=</span> ms <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>reject<span class=\"token punctuation\">,</span> ms<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>使用 reject 而不是 resolve 的好处，可以让代码更加简洁。因为进入 <em>fulfilled</em> 的情况只有一种，就是在 ms 之内请服务器响应并返回了。而在 rejected 状态下，就是超时的逻辑（<strong>注意 ⚠️，这里不考虑请求异常的情况</strong>）</p>\n<p>根据上面的说法，很容易写出一个 naive 的实现</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> rep <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">race</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span><span class=\"token number\">400</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>rep<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>很显然，这不符合我们的要求。如果没有进入 <code class=\"language-text\">catch</code> 里，世界和平，但是如果进入 <code class=\"language-text\">catch</code> 里，谁帮我们继续处理返回的数据呢？换句话说，它只把一个 loading 丢给你，其他就不管了！</p>\n<p>接着，我们改进一下</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">try</span>\n  <span class=\"token keyword\">const</span> rep <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">race</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span><span class=\"token number\">400</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>rep<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">const</span> rep <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>rep<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>嗯，看上去解决了上面的问题。不过仔细一看就能发现，<strong>不是白白多发了一次请求</strong>么，没有从本质上解决问题。\n其实我们已经接近那隧道尽头的光了。如果 <code class=\"language-text\">const rep = await fetch(url)</code> 这句话不会重新发送请求，而仅仅只是接着第一次调用 <code class=\"language-text\">fetch(url)</code> 的场景，承载着那个 promise，是不是就解决我们的问题了？</p>\n<p>是的，我们只需要将 <code class=\"language-text\">fetch(url)</code> 保存下来，就可以做到了。这是最终实现</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">const</span> fetchPromise <span class=\"token operator\">=</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token keyword\">const</span> rep <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">race</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span><span class=\"token number\">400</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> fetchPromise<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>rep<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> loading<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> rep <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> fetchPromise<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>rep<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>It’s Done 😎.</p>\n<h2>让它更加通用</h2>\n<p>接下来的任务就是让这个场景更加通用，可以通过一个<strong>高阶函数</strong>，把普通的异步函数作为参数传入，并返回一个支持该特性的函数。</p>\n<p>我们先写一个最符合直觉的函数，它需要</p>\n<ol>\n<li>异步函数</li>\n<li>超时时间</li>\n<li>接口返回后的回调</li>\n<li>超时的回调</li>\n</ol>\n<p>下面使用 Promise 而不是 async 来实现，因为这样会让代码更简单。实现如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">timeout</span> <span class=\"token operator\">=</span> ms <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">,</span> ms<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ajax</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>api<span class=\"token punctuation\">,</span> ms<span class=\"token punctuation\">,</span> resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> request <span class=\"token operator\">=</span> <span class=\"token function\">api</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">race</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>request<span class=\"token punctuation\">,</span> <span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span>ms<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> err <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span></span>    <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">return</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这样已经能拿到我们需要的效果了，但是一个函数介绍四个参数的话，未免有点多，让人觉得不太自然。\n通过观察第 5 行和第 7 行，如果我们把 第 5 行改成 <code class=\"language-text\">request.then(resolve, err =&gt; {)</code> 的话，发现它和第七行的功能类似，都是在等待 <code class=\"language-text\">request</code> 被 <em>resolve</em> 后，继续调用 resolve。接着，如果有一种方法，可以将第一个 <code class=\"language-text\">then(resolve</code> 中的 resolve <strong>委托到</strong>下一个 then 语句运行，我们就可以省略 resolve 这个参数。\n因为 <code class=\"language-text\">return Promise.resolve().then(resolve)</code> 和 <code class=\"language-text\">return Promise.resolve()</code> 是等价的。</p>\n<p>先看下改进后的代码。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">timeout</span> <span class=\"token operator\">=</span> ms <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">,</span> ms<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ajax</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>api<span class=\"token punctuation\">,</span> ms<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> request <span class=\"token operator\">=</span> <span class=\"token function\">api</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">race</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>request<span class=\"token punctuation\">,</span> <span class=\"token function\">timeout</span><span class=\"token punctuation\">(</span>ms<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>undefined<span class=\"token punctuation\">,</span> err <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> request<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里代码和 👆 的区别主要是第五行中的 then，不再是 resolve，而是 undefined。为什么呢？\n看下 MDN 中，关于 <code class=\"language-text\">Promise.then</code> 的一个特别的定义。</p>\n<blockquote>\n<p>If one or both arguments are omitted or are provided non-functions, then then will be missing the handler(s), but will not generate any errors. If the Promise that then is called on adopts a state (fulfillment or rejection) for which then has no handler, a new Promise is created with no additional handlers, simply adopting the final state of the original Promise on which then was called.</p>\n</blockquote>\n<p>翻译过来其实就是，如果 then 里的两个参数有一个函数没有声明的话，就会直接返回一个新的 Promise，并抛出去。虽然看上去很难理解，其实，我们常用的 <code class=\"language-text\">catch</code> 不就是一个简单的 <code class=\"language-text\">then(undefined, reject)</code> 么？最后可以改成</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const ajax = (api, ms, reject) =&gt; (...args) =&gt; {\n  const request = api(...args);\n  return Promise.race([request, timeout(ms)]).catch(err =&gt; {\n    reject(err);\n    return request;\n  });\n};</code></pre></div>\n<p>好了，最后的代码，仅仅 7 行就搞定了，是不是很出乎意料？</p>\n<h2>未解决问题</h2>\n<p>在整个实现中，我们忽略了一个问题，那就是 request 也有 <strong>throw 异常</strong> 的情况，那么一个关键的问题就需要在 catch 中区分到底是 超时还是服务器异常导致的问题。而为了区分这个，最好的方式就是 Symbol。\n一个最简单的方式可以将 timeout 改成</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">timeout</span> <span class=\"token operator\">=</span> ms <span class=\"token operator\">=></span>\n  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>Symbol<span class=\"token punctuation\">.</span><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">'timeout'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> ms<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>接着我们在 catch 的时候做一个判断，将服务端异常的造成的问题抛出去</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>err <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Symbol<span class=\"token punctuation\">.</span><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">'timeout'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> request<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">throw</span> err<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"title":"解决 loading 闪烁的问题","spoiler":"无条件 loading 是有代价的","date":"2019/01/12"}}},"pageContext":{"slug":"/solve-fresh-of-loading/solve the fresh of loading/","previous":{"fields":{"slug":"/react-trap/"},"frontmatter":{"title":"一些 React 中的刁钻问题","spoiler":"收集一些不为人所知的，React 的细节问题。帮助自己理顺 React 内部深层的逻辑"}},"next":{"fields":{"slug":"/react-as-a-runtime/"},"frontmatter":{"title":"React as a UI Runtime","spoiler":"An in-depth description of the React programming model."}}}}